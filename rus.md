# Исконно отзывчивые изображения

## Как всё началось

Наша история берёт своё начало из древних времен когда WURFLы бродили дикими просторами и вебсайты, заточенные под мобильные устройства, были в ходу. В те времена разработчик, который хотел дать пользователям доступ к своему сайту, создавал упрощённую версию «настоящего» сайта и привязывал его загрузку к определению агента пользователя. 

Как вам несомненно известно, быстрое нарастание разнообразия устройств с множеством вариантов размера области просмотра и большим количеством различных возможностей привело к потребности в лучшем способе обслуживания пользователей мобильных (и не очень мобильных) устройств. [Отзывчивый веб-дизайн][1] объединил возможности браузеров и технологии CSS для создания вебсайтов, которые подстраиваются под устройство, на котором их просматривают, и на любом устройстве выглядят безупречно. Это позволило разработчикам прекратить волноваться по поводу ненадёжной системы определения устройства и подходить к созданию сайтов с точки зрения многообразия размеров областей просмотра.

Однако хотя отзывчивые сайты и *выглядели* по-разному на каждом устройстве, под капотом [большинство из них продолжило загружать те же ресурсы для всех устройств][2]. И так как [большая доля загружаемых сайтами байтов приходилась][3] на изображения, сообщество разработчиков начало искать возможные способы избежать такого расточительства. 

Это дало начало (очень) длительному процессу в котором на различных списках рассылок выдвигались множественные предположения, проблема анализировалась в обсуждениях под [заметками в блогах][4], рассматривались [разнообразные сценарии использования][5]. Сообщество разработчиков объединилось в [Общественную группу по отзывчивым изображениям][6] и вот когда в обсуждении приняли участвие разработчики браузеров, было наконец достигнуто соглашение. Сообщество и разработчики браузеров общими усилиями создали спецификацию для [элемента `picture`][7], которая была добавлена в [спецификацию HTML][8], и уже в начале этой осени её реализации на движках Blink и Gecko увидят свет!

Однако, минуточку. Это всё конечно хорошо, но какое мне дело до отзывчивых изображений? Что они могут дать лично *мне*?

## Изображения с фиксированной шириной

Давайте представим что на сайте, над которым вы работаете, присутствуют изображения, сохраняющие свои размеры независимо от размера области просмотра. Т.е. сайт, над которым вы работаете, отзывчивым не является. Единственная присущая им «отзывчивая» черта это то что вы хотите чтобы они выглядели хорошо на высококласных устройствах с большим соотношением логических и физических пикселей (или DPR, как его ласково называют его создатели), однако вы не хотите чтобы «изображения под ретину» загружались на устройства, где в них нет необходимости.

Представим что у вас есть изображение в 500 пикселей. Вы хотите чтобы оно отображалось на экранах ретина *в таком же* размере, но в лучшем качестве. 

Сделать это вам позволит синтаксис вроде этого:

   <img src="cat_500px.jpg"
    	srcset="cat_750px.jpg 1.5x, cat_1000px.jpg 2x"
    	width="500px" alt="смешнойкот">

Коротко и мило, не правда ли? Длинные объяснения здесь ни к чему. Вы просто даёте браузеру список ресурсов и их `x`-дескрипторов (описывающих DPR экрана), разделённых запятыми и браузер выбирает наиболее подходящий вариант.

Обратите внимание, что изображение с DPR 1х указано в атрибуте `src`, что также делает его запасным ресурсом. Не нужно прописывать один и тот же ресурс дважды!

## Изображения с переменной шириной

Если же ваш сайт является «классическим» отзывчивым сайтом с «гибкими» изображениями, кода приведённого выше недостаточно. Он конечно лучше чем ничего, но одно то же изображение будет загружаться на экранах с шириной 1920px и 360px если плотность пикселей у них одинакова, что делает неизбежными существенные компромисы в плане пользовательского опыта: придётся смириться либо с отсутствием чёткости либо с большой продолжительностью загрузки.

Что нам действительно нужно, так это чтобы браузер мог выбрать подходящее изображение из предложенных согласно имеющемуся DPR и размеру области просмотра. Как же нам этого добиться?

 В идеале было бы прописать набор доступных изображений с указанием их физического размера (т.е. их ширины в пискелях) и предоставить браузеру возможность загрузить одно из них исходя из размера в котором изображение должно быть отображено.

 Однако здесь есть одна проблема: браузер не знает в каком размере будет отображаться изображение когда ему нужно выбрать ресурсы, которые будут загружены. Размер отображения изображения зависит от конечной структуры страницы, которая часто зависит от внешнего CSS, а также поддаётся влиянию со стороны размера изображения и других изображений на странице. Безумный замкнутый круг какой-то.

Итак, если мы хотим чтобы браузер загрузил правильный ресурс, нам нужно дать ему подсказку насчёт конечных размеров отображения картинки, а это попросту невозможно. Конечно же, в зависимости от дизайна, размеры изображения вариируются в зависимости от структуры страницы.

Мы столкнулись с довольно серьезным ограничением, которое и стало одной из причин такой длительной продолжительности поиска решения для этой проблемы. В конце концов, [Таб Аткинс (Tab Atkins)][9] и [Джон Меллор (John Mellor)][10] из Google предложили вариант синтаксиса, призванный стать решением для сценария с «гибкими изображениями», который был тут же внесён в спецификацию по отзывчивым изображениям (Таб и [Саймон Питерс (Simon Pieters)][11] из Opera взяли на себя большую часть редактирования этой спецификации).

Давайте взглянем на пример кода, который следует использовать если у вас есть изображение, изменяющееся в размере при разных ключевых точках макета:

    <img sizes="(max-width: 30em) 100vw,
    			(max-width: 50em) 50vw,
    			calc(33vw - 100px)"
    	srcset="swing-200.jpg 200w,
	    		swing-400.jpg 400w,
    			swing-800.jpg 800w,
    			swing-1600.jpg 1600w"
    	src="swing-400.jpg" alt="Махи гирей">

На первый взгляд он может показаться слишком громоздким, так что давайте разобъем его на части. `w`-дескрипторы синтаксиса `srcset` не слишком отличаются от `x`-дескрипторов, которые нам встретились ранее. В атрибуте `srcset` содержится перечень ресурсов, предоставленных браузеру на выбор, а `w`-дескрипторы сообщают браузеру физические размеры каждого из них.

Но разве мы только что не говорили что браузер не может ждать пока будут подсчитаны размеры отображения изображения потому что это приведёт к существенным заминкам и потенциальным повторным загрузкам? А если браузер не может ждать размеры отображения, как он может выбрать какое изображение загружать исходя из его физических размеров?

Именно здесь на сцене появляется атрибут `sizes`. Он состоит из пары значений, в которой первое (необязательное) значение - это медиа-условие (медиа-запрос без указанного медиа-типа), а второе - CSS-длина.

Браузер проходится по медиа-условиям и ищет первое, которое соответствует текущему окружению (в большинстве случаев «текущее окружение» == текущей области просмотра). Второе значение в паре (или же первое, если медиа-условие не указано) прописывается как «действительный размер» пары и описывает ожидаемый размер в котором будет отображаться изображение. Это та подсказка, которую разработчик даёт браузеру чтобы тот мог выбрать нужный ресурс для загрузки.

Действительный размер подходящей пары вместе с DPR экрана (и возможно другими факторами) используется браузером для определения какой ресурс наиболее подходит для загрузки и отображения.

Вернёмся к нашему примеру кода выше и представим что он выполняется в браузере с областью просмотра шириной 20em от исходного размера шрифта по умолчанию составляющего 16px (т.е. ширина области просмотра - 320px). Браузер перебирает пары `sizes` и выбирает первую: `(max-width: 30em) 100vw`. Это указывает на то, что изображение скорее всего будет отображено по всей ширине области просмотра, следовательно исходя из предположения что DPR экрана равно 1, браузер скорее всего загрузит первый ресурс с шириной более 320px, которым является `swing-400.jpg`. Если значение DPR равно 2, загружаемый ресурс должен быть в два раза больше чтобы подойти для экрана с такой плотностью, так что браузер вероятно попытается скачать первый ресурс с шириной больше 640px, которым является `swing-800.jpg`.

Если же область просмотра составляет 40em (640px), тогда подходит пара `(max-width: 50em) 50vw` и скорее всего изображение займёт половину ширины области просмотра. Это значит что вероятно будет выбрано первое изображение с шириной больше 320px для экранов с плотностью 1x и больше 640px для экранов с плотностью 2x, загруженные ресурсы вероятно будут идентичными в обеих случаях.

Почему в двух абзацах выше я так часто использовал «скорее всего» и «вероятно»? Потому что когда дело касается ресурсов указанных в `srcset`, браузер волен выбирать любой из ресурсов, который его алгоритмы сочтут подходящим. Это значит что вы, веб-разработчик, не можете твердо рассчитывать на то, что браузер выберет и загрузит именно тот ресурс, который вам бы хотелось. И это хорошо, потому что браузер получает пространство для инноваций в этой области: добавления предпочтений пользователя, учёта скорости соединения с сетью и других факторов, которые в будущем могут повлиять на процесс принятия решения. И поскольку все ресурсы должны отличаться только качеством, расхождение в выборе ресурсов не должно никак влиять на структуру вашей страницы.

Стоит отметить что если атрибут `sizes` не прописан, в качестве действительного размера по умолчанию используется `100vw`, так как он представляет максимально возможный размер отображения изображения без горизонтальной полосы прокрутки. 

А что если вы хотите видеть немного разные изображения для разных макетов, например, с разным соотношением сторон или большей фокусировкой на центральном объекте или ещё каким-либо проявлением креативности вашей натуры?

Именно для этого было придуано художественное руководство!

## Художественное руководство

Термин «художественное руководство» (art direction) в отношении отзывчивых изображений [впервые использовал][12] [Джейсон Григсби (Jason Grigsby)][13], он обозначает те случаи когда вы хотите чётко указать какое изображение должно загружаться для конкретных ключевых точек отзывчивого макета. Художественное руководство следует использовать когда ваши изображения отличаются не только качеством, но также соотношением сторон, областью обрезки, расположением надписей, ракурсом и т.д. Возможные варианты безграничны!

В таких случаях, вы хотите убедиться что при определённых размерах страницы ваши пользователи увидят именно то изображение, которое вы хотели чтобы они увидели.

Синтаксис художественного руководства примерно следующий:

    <picture>
        <source media="(min-width: 45em)" srcset="large.jpg">
        <source media="(min-width: 32em)" srcset="med.jpg">
        <img src="small.jpg" alt="Президент вручает награду.">
    </picture>

Здесь мы опять даём браузеру перечень доступных ресурсов. Разница в том, что это список тегов `<source>` и алгоритм их выбора [чётко прописан в спецификации][14].

Браузер придерживается этого алгоритма буква-в-букву и каждый раз выбирает именно задуманный вами тег. 

Похоже на то как выполняется алгоритм для `sizes`, браузер проходится по списку ресурсов и выбирает первый подходящий. Выбор может основываться на совпадении с атрибутами `media` и `type`. (Почему `type`? Мы это увидим немного позже).

Если подходят оба атрибута или же они отсутствуют, выбирается соответствующий ресурс. Если ни один из `<source>` не подходит, загружается изображение из `<img>`. Когда выбран элемент, который будет служить источником для этого изображения, происходит выбор ресурса, который будет загружен, на основе атрибутов `srcset` и `sizes` по тому же алгоритму, который мы обсудили ранее.

Несколько моментов, которые следует учитывать:

* `<source src>` ничего не делает и игнорируется в процессе выбора изображения. Используйте `<source srcset>`.
* Хотя `picture` и является родительским элементом, главная ответственность в этом случае лежит на элементе `<img>`. `<img>` использует свой родительский элемент `<picture>` и одноуровневые `<source>`, прописанные раньше него, для выбора ресурса для загрузки, но в конце концов именно `<img>` используется для отображения ресурса. Это значит что `<img>` должен присутствовать в коде, иначе изображение не будет отображено на экране. Это также пригодится на случай отсутствия поддержки: `<img>` должен присутствовать в коде чтобы обеспечить запасной вариант для более старых браузеров, так что его нужно прописывать в любом случае, если `<img>` в коде нет, изображение отображаться не будет.
* И последнее но не наименее важное: если вы хотите стилизироваь изображение, стили нужно прописывать для `<img>` как вы делаете эо обычно. Таб Аткинс очень точно высказался по этому поводу: представляйте что `<picture>` - это волшебная оболочка вокруг вашего `<img>`. То же касается текста `alt`. Его нужно прописывать для `<img>` как обычно.

### Почему для художественного руководства нельзя использовать `sizes/srcset`?

Согласно начальному замыслу, синтаксис `sizes/srcset` учитывает ширину области просмотра и плотность пикселей экрана. Добавление возможностей художественного руководства в тот же синтаксис значило бы что веб-разработчику пришлось бы эксплицитно прописывать в разметке все возможные комбинации DPR и ширины области просмотра.

Это значительно усложнило бы работу веб-разработчиков и сделало бы код значительно более сложным для понимания и слишком многословным.

## Запасной контент на случай отсутствия поддержки формата изображения

Ещё одна вещь которую вам может захотеться сделать когда речь идёт об изображениях (не обязательно отзывчивых), это предоставление разных файловых форматов для разных браузеров, в зависимости от их поддержки. Кроме «традиционных» форматов файлов, поддерживаемых браузерами (т.е. PNG, JPEG и GIF), существует несколько более новых форматов, активно пропагандируемых разработчиками браузеров. Эти форматы как правило работают лучше традиционных, так как в них предусмотрены различные усовершенствования алгоритмов, делающих сжатие изображений более эффективным. Если конкретней, Google проталкивает формат [WebP][15], а Microsoft - [JPEG-XR][16].

Проблема в том, что этим новым форматам не хватает повсеместной поддержки, характерной для традиционных форматов, это значит что если вы пропишите их в качестве значения для `<img src>`, браузеры, поддерживающие их, обеспечат улучшенный пользовательский опыт, а в тех, что их не поддерживают, изображения не будут отображены вообще. Вряд ли это хорошо.

До сегодня единственный способ использования таких форматов без вреда для пользователей браузеров, которые их не поддерживают, состоял в согласовании содержания, применении HTTP-заголовка `Accept` или определении агента пользователя. Хотя такой подход в большинстве случаев работает нормаально, у него есть некоторые недостатки. При его применении не избежать некоторой возни на стороне сервера, на которую у некоторых разработчиков не хватает знаний или желания. При его использовании также возникают трудности с кэшированием таких изображений.

Благодаря синтаксису `<picture>`, у нас наконец есть возможность определить механизм предоставления запасного контента на стороне клиента. Используя атрибут `type` для `<source>`, можно предложить браузеру ссылки на несколько ресурсов и позволить ему выбрать тот, который он поддерживает. Такие механизмы доступны для других ресурсов (напр., шрифтов, видео) уже много лет. А теперь механизм предоставления запасного контента доступен и для изображений.

Синтаксис для запасного контента на случай отсутствия поддержки формата, обрабатываемый на стороне клиента, выглядит примерно так:

    <picture>
        <source type="image/webp" srcset="president.webp">
        <source type="image/vnd.ms-photo" srcset="president.jpxr">
        <img src="president.jpg" alt="Президент даёт кому-то кулаком.">
    </picture>

## Можно ли всё это использовать уже сегодня?

Встроенную поддержку бльшинства возможностей, которые мы сегодня обсудили, с официальными версиями браузеров всё ещё разделяет несколько недель пути, но их несомненно можно начинать использоват ьуже сейчас.

Дескриптор `srcset x` уже поддерживается браузерами начиная с Chrome 34, Opera 21 и будет поддерживаться в Safari 8.

Поддержке элемента `<picture>` суждено быть через несколько недель реализованной в Chrome 38, Opera 25 и Firefox 33. Внедрение синтаксиса `sizes/srcset` в WebKit уже завершено, однако к сожалению, он не был введён в Safari 8. Ещё предстоит поработать (читайте: мне предстоит поработать) над реализацией полного синтаксиса `<picture>` в Safari.

Что касается IE, официально введение `<picture>` находится «на рассмотрении», однако команда разработчиков IE довольно часто посещает IRC-канал #respimg и задаёт хорошие вопросы. Будем надеяться что статус вскоре изменится на «в разработке». 

Поддержка элемента `<picture>` была также реализована в [валидаторе][17] W3C, так что его можно использовать для обнаружения ошибок в коде если вы вдруг в нём запутаетесь.

Для этого средства есть соответствующий стандарту полифил под названием [picturefill][18], и даже без него благодаря встроенному запасному контенту `<img>` старые браузеры будут загружать и отображать запасное изображение, а значит опыт пользователя будет таким же каким бы был если бы вы использовали обычный тег `<img>`.

## Отвергнутое предложение

Те из вас, кто пристально следил за сагой с отзывчивыми изображениями, возможно помнят ещё одно предложение под названием «Подсказки для клиента» (Client-Hints). Согласно этому предложению, в некоторых случаях должны были использоваться заголовки HTTP-запросов для информирования браузера об условиях окружения, позволяя серверу адаптировать отсылаемые им изображения должным образом. Такой тип решений в общем называют  «согласованием контента».

К сожалению, некоторые разработчики браузеров не решились поддержать новые решения по согласованию контента, из-за прошлого негативного опыта с применении решений такого типа. Без поддержки со стороны разработчиков браузеров, работа над подсказками для клиента застопорилась и сейчас над ним никто активно не работает.

## Сообщество

Инициатива по отзывчивым изображением, в отличии от разработки большинства возможностей веб-платформы, исходила от сообщества. Она активно отстаивалась Общественной группой по отзывчивым изображениям, поддерживалась сообществом разработчиков и была просто обречена на успех когда подтянулись ещё и разработчики браузеров. Прямо как в одной большой счастливой семье. 

В том же духе создан некий прецедент по реализации этого подхода в Blink (движке лежащем в основе Chrome и Opera). 

Чтобы развеять [изначальные][19] сомнения по [реализации][20] в проекте Blink, я [разработал план по реализации][21] совместно с командой Blink и начал работу над сопутствующей инфраструктурой.

Сначала я работал над этим в свободное вемя, но затем, когда понял насколько много времени это займёт, на завершающей стадии работы над реализацией этого подхода я трудился полный рабочий день. Моя работа финансировалась сообществом через [кампанию краудфандинга][22], инициированную Общественной группой по отзывчивым изображениям (в частности [Мэттом Маркизом (Mat Marquis)][23] и [Гэри Коуди (Geri Coady)][24]).

Веб-разработчики, агентства, в том числе Google и Opera, внесли свой вклад в кампанию, благодаря чему я получил возможность работать полный день над реализацией и привести её в нынешнее состояние.

## Подведём итог

Довольно длительное время отзывчивые изображения были болезненным вопросом в процессе разработки вебсайтов. Теперь, наконец-то, у нас для него почти готово естественное решение.

Этот подход можно использовать уже сегодня, применяя picturefill или без него, и таким образом экономить время и деньги ваших пользователей!

[1]: http://alistapart.com/article/responsive-web-design
[2]: http://www.guypo.com/uncategorized/real-world-rwd-performance-take-2/
[3]: http://httparchive.org/interesting.php#bytesperpage
[4]: http://blog.cloudfour.com/responsive-imgs/
[5]: http://usecases.responsiveimages.org/
[6]: http://responsiveimages.org/
[7]: http://picture.responsiveimages.org/
[8]: http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content.html
[9]: https://twitter.com/tabatkins
[10]: https://twitter.com/john__mellor
[11]: https://twitter.com/zcorpan
[12]: http://blog.cloudfour.com/a-framework-for-discussing-responsive-images-solutions/
[13]: https://twitter.com/grigs
[14]: http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content.html#select-an-image-source
[15]: https://developers.google.com/speed/webp/
[16]: http://msdn.microsoft.com/en-us/library/windows/desktop/hh707223.aspx
[17]: http://validator.w3.org/
[18]: https://scottjehl.github.io/picturefill/
[19]: http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2014-January/041833.html
[20]: http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2014-January/041910.html
[21]: https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/9xIjDTOwbeI/1mL2lDYaHFYJ
[22]: https://www.indiegogo.com/projects/picture-element-implementation-in-blink
[23]: https://twitter.com/wilto
[24]: https://twitter.com/hellogeri